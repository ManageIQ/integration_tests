import argparse
import os
import re
import shutil
import subprocess
import sys
import tempfile
from contextlib import contextmanager
from pathlib import Path
from pprint import PrettyPrinter

import click

from cfme.scripting import quickstart
from cfme.utils.path import get_rel_path
from cfme.utils.path import project_path
from cfme.utils.path import requirements_path
from requirements import RepoImportScanner


# Check for default template exists, its passed to freeze if so
# if user passes bad path for --extra-template, freeze will hit RuntimeError
DEFAULT_EXTRA_TEMPLATE = requirements_path.join("template_non_imported.txt")

# These files is written out to, don't have to assert it exists yet
DEFAULT_SCAN_TEMPLATE = requirements_path.join("template_scanned_imports.txt")
DEFAULT_FROZEN_OUTPUT = requirements_path.join("frozen.txt")


@click.group(help="Functions for adding, updating, and freezing requirements")
def main():
    pass


venv_opt = click.option(
    '--venv',
    'venv',
    default=None,
    help='The virtualenv directory used to freeze in'
)


venv_keep_opt = click.option(
    '--keep-venv/--discard-venv',
    'keep_venv',
    default=False,
    show_default=True,
    help='Whether to keep or discard the venv after freeze.'
)


scan_template_opt = click.option(
    '--scan-template',
    'scan_template',
    show_default=True,
    default=get_rel_path(str(DEFAULT_SCAN_TEMPLATE)),
    help='The path to the template file (pip -r arg) for scanned imports, will be overwritten',
)


@main.command(help="Scan repository files for imports from pip-installable packages")
@scan_template_opt
def scan(scan_template):
    scanner = RepoImportScanner(path=str(project_path), output=scan_template)
    scanner.import_statement = re.compile(r"^\s*(?:from|import) ([a-zA-Z0-9-_]+)(?:.*)",
                                          re.MULTILINE)
    scan = scanner.run()
    scan.libraries_found.sort()
    pretty_printer = PrettyPrinter()
    print("Found the following packages imported:")
    pretty_printer.pprint(scan.libraries_found)
    scan.output()  # writes to the output file

#@main.command(help='')


# parser.add_argument(
#     "--upgrade-only",
#     default=None,
#     help="updates only the given package instead of all of them"
# )
# parser.add_argument_group()
# parser.add_argument(
#     "--scan-only",
#     action="store_true",
#     help="Stop after scanning and writing out to --template, DO NOT run freeze",
# )
# parser.add_argument(
#     "--templates",
#     nargs="+",
#     dest="template_files",
#     default=[str(DEFAULT_SCAN_TEMPLATE), str(DEFAULT_EXTRA_TEMPLATE)],
#     help="The paths to the template files, used as -r arguments to pip",
# )
# parser.add_argument(
#     "--frozen-output",
#     dest="frozen_output",
#     default=str(DEFAULT_FROZEN_OUTPUT),
#     help="The path for the output frozen file. Used for freeze",
# )
#
#
# parser.add_argument(
#     "--constraints",
#     default="requirements/constraints.txt",
#     help="The frozen file to start from for specific package upgrade, requires --upgrade-only",
# )
#
#
# def pip_freeze(venv, out):
#     """
#     this one a frozen requirement file from a virtualenv
#     for sanity it adds a comment about the freeze_all script
#     """
#     print(
#         """\
# # this requirement file is autogenerated, please run requirements/freeze_all.py to upgrade correctly
# # currently requirements/freeze_all.py needs to be executed for both python2 and python3 !
# # to upgrade a single package use requirements/freeze_all.py --upgrade-only apackage
#
# """,
#         file=out,
#         flush=True,
#     )
#     quickstart.venv_call(venv, "pip", "freeze", stdout=out, call=subprocess.check_call)
#
#
# @contextmanager
# def freeze_target_venv(path, keep=False):
#     """
#     Create a temp directory (and clean up after if keep is False) or just return the given path
#
#     Args:
#         path (str): The path to the virtualenv directory (or None)
#         keep (bool): Whether to keep (True) or delete (False) the venv directory after freezing
#     """
#     if path is None:
#         tmp_path = tempfile.mkdtemp(suffix="-miq-freeze-venv")
#         try:
#             yield tmp_path
#         finally:
#             if not keep:
#                 shutil.rmtree(tmp_path)
#     else:
#         yield path
#
#
# def run_freeze(args):
#     with maybe_transient_venv_dir(args.venv, args.keep) as venv:
#         quickstart.setup_virtualenv(venv, use_site=False)
#         # build string of `-r template.txt -r template2.txt -r template3.txt`
#         dash_r_args = []
#         for template in args.templates:
#             # this is a bit odd, but its done because of how its passed to venv_call and compiled
#             dash_r_args.append("-r")
#             dash_r_args.append(template)
#
#         constraint_args = []
#         if args.upgrade_only:
#             # Constrain on the existing frozen file so that only the upgrade package changes
#             constraint_args.append("-c")
#             constraint_args.append(args.out)
#
#         if args.upgrade_only:
#             # install of the template files, constrained
#             quickstart.venv_call(venv, "pip", "install", "-c", args.constraints, *dash_r_args)
#             # now upgrade the given package, including dependencies
#             quickstart.venv_call(venv, "pip", "install", "-U", args.upgrade_only)
#
#         # full install of the template, latest versions where not in constraints
#         quickstart.venv_call(venv, "pip", "install", "-c", args.constraints, *dash_r_args)
#
#         if args.out is None:
#             freeze(venv, sys.stdout)
#         else:
#             with open(args.out, "w") as out:
#                 freeze(venv, out)
#
#
# def main(conf):
#
#     """
#     this one simply runs the freezing for all templates
#
#     this is the one you should always use
#     """
#     scan = RepoImportScanner(path=str(project_path), output=conf.scan_template)
#     scan.import_statement = re.compile(r"^\s*(?:from|import) ([a-zA-Z0-9-_]+)(?:.*)", re.MULTILINE)
#     scan = scan.run()
#     scan.libraries_found.sort()
#     pretty_printer = PrettyPrinter()
#     print("Found the following packages imported:")
#     pretty_printer.pprint(scan.libraries_found)
#     scan.output()  # writes to the output file
#
#     if not conf.scan_only:
#         pip_templates = [conf.scan_template]
#         if Path(conf.extra_template).exists():
#             pip_templates.append(conf.extra_template)
#
#         with freeze.maybe_transient_venv_dir(None, False) as venv:
#             args = argparse.Namespace(
#                 venv=venv,
#                 keep=True,
#                 templates=pip_templates,
#                 out=conf.frozen_output,
#                 upgrade_only=conf.upgrade_only,
#             )
#             freeze.main(args)
