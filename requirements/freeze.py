#!/usr/bin/env python3
"""
outputs the frozen packages
"""
import argparse
import os
import shutil
import subprocess
import sys
import tempfile
from contextlib import contextmanager

from cfme.scripting import quickstart
from requirements.freeze_all import DEFAULT_EXTRA_TEMPLATE
from requirements.freeze_all import DEFAULT_FROZEN_OUTPUT
from requirements.freeze_all import DEFAULT_SCAN_TEMPLATE

os.environ.pop("PYTHONPATH", "")

parser = argparse.ArgumentParser(description=__doc__.strip())
parser.add_argument("--venv", default=None, dest="venv", help="The virtualenv used to freeze in")
parser.add_argument("--keep-venv", action="store_true", dest="keep")
parser.add_argument(
    "--templates",
    nargs="+",
    default=["requirements/template_scanned_imports.txt", "requirements/template_non_imported.txt"],
    help="one or many template files passed to pip as -r",
)
parser.add_argument(
    "--constraints",
    default="requirements/constraints.txt",
    help="The frozen file to start from for specific package upgrade, requires --upgrade-only",
)
parser.add_argument(
    "--out", default=str(DEFAULT_FROZEN_OUTPUT), help="the file where packages should be written to"
)
parser.add_argument(
    "--upgrade-only",
    default=None,
    help="updates the given package and its dependencies, requires current frozen file."
    "Uses --out as current frozen file",
)


def freeze(venv, out):
    """
    this one a frozen requirement file from a virtualenv
    for sanity it adds a comment about the freeze_all script
    """
    print(
        """\
# this requirement file is autogenerated, please run requirements/freeze_all.py to upgrade correctly
# currently requirements/freeze_all.py needs to be executed for both python2 and python3 !
# to upgrade a single package use requirements/freeze_all.py --upgrade-only apackage

""",
        file=out,
        flush=True,
    )
    quickstart.venv_call(venv, "pip", "freeze", stdout=out, call=subprocess.check_call)


@contextmanager
def maybe_transient_venv_dir(path, keep):
    """
    this one does optional cleanup if it needs to make a tmpdir
    """
    if path is None:
        tmp_path = tempfile.mkdtemp(suffix="-miq-QE-rebuild-venv")
        try:
            yield tmp_path
        finally:
            if not keep:
                shutil.rmtree(tmp_path)
    else:
        yield path


def main(args):
    with maybe_transient_venv_dir(args.venv, args.keep) as venv:
        quickstart.setup_virtualenv(venv, use_site=False)
        # build string of `-r template.txt -r template2.txt -r template3.txt`
        dash_r_args = []
        for template in args.templates:
            # this is a bit odd, but its done because of how its passed to venv_call and compiled
            dash_r_args.append("-r")
            dash_r_args.append(template)

        constraint_args = []
        if args.upgrade_only:
            # Constrain on the existing frozen file so that only the upgrade package changes
            constraint_args.append("-c")
            constraint_args.append(args.out)

        if args.upgrade_only:
            # install of the template files, constrained
            quickstart.venv_call(venv, "pip", "install", "-c", args.constraints, *dash_r_args)
            # now upgrade the given package, including dependencies
            quickstart.venv_call(venv, "pip", "install", "-U", args.upgrade_only)

        # full install of the template, latest versions where not in constraints
        quickstart.venv_call(venv, "pip", "install", "-c", args.constraints, *dash_r_args)

        if args.out is None:
            freeze(venv, sys.stdout)
        else:
            with open(args.out, "w") as out:
                freeze(venv, out)


if __name__ == "__main__":
    main(parser.parse_args())
